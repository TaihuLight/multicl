const char *cl_source_spmv =
"#define VECTOR_SIZE 32\n"
"\n"
"#ifdef SINGLE_PRECISION\n"
"#define FPTYPE float\n"
"#elif K_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64: enable\n"
"#define FPTYPE double\n"
"#elif AMD_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_amd_fp64: enable\n"
"#define FPTYPE double\n"
"#endif\n"
"\n"
"#ifdef USE_TEXTURE\n"
"__constant sampler_t texFetchSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;\n"
"FPTYPE texFetch(image2d_t image, const int idx) {\n"
"      int2 coord={idx%MAX_IMG_WIDTH,idx/MAX_IMG_WIDTH};\n"
"#ifdef SINGLE_PRECISION\n"
"        return read_imagef(image,texFetchSampler,coord).x;\n"
"#else\n"
"          return as_double2(read_imagei(image,texFetchSampler,coord)).x;\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// ****************************************************************************\n"
"// Function: spmv_csr_scalar_kernel\n"
"//\n"
"// Purpose:\n"
"//   Computes sparse matrix - vector multiplication on the GPU using\n"
"//   the CSR data storage format, using a thread per row of the sparse\n"
"//   matrix; based on Bell (SC09) and Baskaran (IBM Tech Report)\n"
"//\n"
"// Arguments:\n"
"//   val: array holding the non-zero values for the matrix\n"
"//   vec: dense vector for multiplication\n"
"//   cols: array of column indices for each element of the sparse matrix\n"
"//   rowDelimiters: array of size dim+1 holding indices to rows of the matrix\n"
"//                  last element is the index one past the last\n"
"//                  element of the matrix\n"
"//   dim: number of rows in the matrix\n"
"//   out: output - result from the spmv calculation \n"
"//   \n"
"// Returns:  nothing\n"
"//           out indirectly through a pointer\n"
"//\n"
"// Programmer: Lukasz Wesolowski\n"
"// Creation: June 28, 2010\n"
"//\n"
"// Modifications:\n"
"//\n"
"// ****************************************************************************\n"
"__kernel void \n"
"spmv_csr_scalar_kernel( __global const FPTYPE * restrict val, \n"
"#ifdef USE_TEXTURE\n"
"                        image2d_t vec, \n"
"#else\n"
"                        __global const FPTYPE * restrict vec, \n"
"#endif\n"
"                        __global const int * restrict cols, \n"
"                        __global const int * restrict rowDelimiters, \n"
"                       const int dim, __global FPTYPE * restrict out) \n"
"{\n"
"    int myRow = get_global_id(0); \n"
"\n"
"    if (myRow < dim) \n"
"    {\n"
"        FPTYPE t=0; \n"
"        int start = rowDelimiters[myRow];\n"
"        int end = rowDelimiters[myRow+1];\n"
"        for (int j = start; j < end; j++) \n"
"        {\n"
"            int col = cols[j]; \n"
"#ifdef USE_TEXTURE\n"
"            t += val[j] * texFetch(vec,col);\n"
"#else\n"
"            t += val[j] * vec[col];\n"
"#endif\n"
"        }\n"
"        out[myRow] = t; \n"
"    }\n"
"}\n"
"\n"
"// ****************************************************************************\n"
"// Function: spmv_csr_vector_kernel\n"
"//\n"
"// Purpose:\n"
"//   Computes sparse matrix - vector multiplication on the GPU using\n"
"//   the CSR data storage format, using a warp per row of the sparse\n"
"//   matrix; based on Bell (SC09) and Baskaran (IBM Tech Report)\n"
"//\n"
"// Arguments:\n"
"//   val: array holding the non-zero values for the matrix\n"
"//   vec: dense vector for multiplication\n"
"//   cols: array of column indices for each element of the sparse matrix\n"
"//   rowDelimiters: array of size dim+1 holding indices to rows of the matrix\n"
"//                  last element is the index one past the last\n"
"//                  element of the matrix\n"
"//   dim: number of rows in the matrix\n"
"//   out: output - result from the spmv calculation \n"
"//   \n"
"// Returns:  nothing\n"
"//           out indirectly through a pointer\n"
"//\n"
"// Programmer: Lukasz Wesolowski\n"
"// Creation: June 28, 2010\n"
"//\n"
"// Modifications:\n"
"//\n"
"// ****************************************************************************\n"
"__kernel void \n"
"spmv_csr_vector_kernel(__global const FPTYPE * restrict val, \n"
"#ifdef USE_TEXTURE\n"
"                       image2d_t vec, \n"
"#else\n"
"                       __global const FPTYPE * restrict vec, \n"
"#endif\n"
"                       __global const int * restrict cols, \n"
"                       __global const int * restrict rowDelimiters, \n"
"                       const int dim, __global FPTYPE * restrict out) \n"
"{\n"
"    // Thread ID in block\n"
"    int t = get_local_id(0);\n"
"    // Thread ID within warp\n"
"    int id = t & (VECTOR_SIZE-1); \n"
"    // One row per warp\n"
"    int vecsPerBlock = get_local_size(0) / VECTOR_SIZE;\n"
"    int myRow = (get_group_id(0) * vecsPerBlock) + (t / VECTOR_SIZE);\n"
"\n"
"    __local volatile FPTYPE partialSums[128]; \n"
"    partialSums[t] = 0; \n"
"\n"
"    if (myRow < dim) \n"
"    {\n"
"        int vecStart = rowDelimiters[myRow];\n"
"        int vecEnd = rowDelimiters[myRow+1];\n"
"        FPTYPE mySum = 0;\n"
"        for (int j= vecStart + id; j < vecEnd; \n"
"             j+=VECTOR_SIZE) \n"
"        {\n"
"            int col = cols[j]; \n"
"#ifdef USE_TEXTURE\n"
"            mySum += val[j] * texFetch(vec,col);\n"
"#else\n"
"            mySum += val[j] * vec[col];\n"
"#endif\n"
"        }\n"
"\n"
"        partialSums[t] = mySum;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Reduce partial sums\n"
"        // Needs to be modified if there is a change in vector\n"
"        // length\n"
"        if (id < 16) partialSums[t] += partialSums[t+16]; \n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (id <  8) partialSums[t] += partialSums[t+ 8];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (id <  4) partialSums[t] += partialSums[t+ 4];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (id <  2) partialSums[t] += partialSums[t+ 2];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (id <  1) partialSums[t] += partialSums[t+ 1];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Write result \n"
"        if (id == 0) \n"
"        {\n"
"            out[myRow] = partialSums[t]; \n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ****************************************************************************\n"
"// Function: spmv_ellpackr_kernel\n"
"//\n"
"// Purpose:\n"
"//   Computes sparse matrix - vector multiplication on the GPU using\n"
"//   the ELLPACK-R data storage format; based on Vazquez et al (Univ. of\n"
"//   Almeria Tech Report 2009)\n"
"//\n"
"// Arguments:\n"
"//   val: array holding the non-zero values for the matrix in column\n"
"//   vec: dense vector for multiplication\n"
"//   major format and padded with zeros up to the length of longest row\n"
"//   cols: array of column indices for each element of the sparse matrix\n"
"//   rowLengths: array storing the length of each row of the sparse matrix\n"
"//   dim: number of rows in the matrix\n"
"//   out: output - result from the spmv calculation \n"
"//   \n"
"// Returns:  nothing directly\n"
"//           out indirectly through a pointer\n"
"//\n"
"// Programmer: Lukasz Wesolowski\n"
"// Creation: June 29, 2010\n"
"//\n"
"// Modifications:\n"
"//\n"
"// ****************************************************************************\n"
"__kernel void\n"
"spmv_ellpackr_kernel(__global const FPTYPE * restrict val, \n"
"#ifdef USE_TEXTURE\n"
"                     image2d_t vec, \n"
"#else\n"
"                     __global const  FPTYPE * restrict vec,                      \n"
"#endif\n"
"                     __global const int * restrict cols, \n"
"                     __global const int * restrict rowLengths, \n"
"                     const int dim, __global FPTYPE * restrict out) \n"
"{\n"
"    int t = get_global_id(0); \n"
"\n"
"    if (t < dim) \n"
"    {\n"
"        FPTYPE result = 0.0;\n"
"        int max = rowLengths[t]; \n"
"        for (int i = 0; i < max; i++) \n"
"        {\n"
"            int ind = i * dim + t; \n"
"#ifdef USE_TEXTURE\n"
"	          result += val[ind] * texFetch(vec,cols[ind]);\n"
"#else\n"
"	          result += val[ind] * vec[cols[ind]];\n"
"#endif\n"
"        }\n"
"        out[t] = result;\n"
"    }\n"
"}\n"
"\n"
"\n"
;

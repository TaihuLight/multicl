const char *cl_source_gr_base =
"#ifdef K_DOUBLE_PRECISION\n"
"#define DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64: enable\n"
"#elif AMD_DOUBLE_PRECISION\n"
"#define DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_amd_fp64: enable\n"
"#endif\n"
"\n"
"// Macros to explicitly control precision of the constants, otherwise\n"
"// known to cause problems for some Compilers\n"
"#ifdef DOUBLE_PRECISION\n"
"#define CPREC(a) a\n"
"#else\n"
"#define CPREC(a) a##f\n"
"#endif\n"
"\n"
"//replace divisions by multiplication with the reciprocal\n"
"#define REPLACE_DIV_WITH_RCP 1\n"
"\n"
"//Call the appropriate math function based on precision\n"
"#ifdef DOUBLE_PRECISION\n"
"#define real double\n"
"#if REPLACE_DIV_WITH_RCP\n"
"#define DIV(x,y) ((x)*(1.0/(y)))\n"
"#else\n"
"#define DIV(x,y) ((x)/(y))\n"
"#endif\n"
"#define POW pow\n"
"#define EXP exp\n"
"#define EXP10 exp10\n"
"#define EXP2 exp2\n"
"#define MAX fmax\n"
"#define MIN fmin\n"
"#define LOG log\n"
"#define LOG10 log10\n"
"#else\n"
"#define real float\n"
"#if REPLACE_DIV_WITH_RCP\n"
"#define DIV(x,y) ((x)*(1.0f/(y)))\n"
"#else\n"
"#define DIV(x,y) ((x)/(y))\n"
"#endif\n"
"#define POW pow\n"
"#define EXP exp\n"
"#define EXP10 exp10\n"
"#define EXP2 exp2\n"
"#define MAX fmax\n"
"#define MIN fmin\n"
"#define LOG log\n"
"#define LOG10 log10\n"
"#endif\n"
"\n"
"//Kernel indexing macros\n"
"#define thread_num (get_global_id(0))\n"
"#define idx2(p,z) (p[(((z)-1)*(N_GP)) + thread_num])\n"
"#define idx(x, y) ((x)[(y)-1])\n"
"#define C(q)     idx2(C, q)\n"
"#define Y(q)     idx2(Y, q)\n"
"#define RF(q)    idx2(RF, q)\n"
"#define EG(q)    idx2(EG, q)\n"
"#define RB(q)    idx2(RB, q)\n"
"#define RKLOW(q) idx2(RKLOW, q)\n"
"#define ROP(q)   idx(ROP, q)\n"
"#define WDOT(q)  idx2(WDOT, q)\n"
"#define RKF(q)   idx2(RKF, q)\n"
"#define RKR(q)   idx2(RKR, q)\n"
"#define A_DIM    (11)\n"
"#define A(b, c)  idx2(A, (((b)*A_DIM)+c) )\n"
"\n"
"__kernel void\n"
"gr_base(__global const real* P, __global const real* T, __global const real* Y,\n"
"		__global real* C, const real TCONV, const real PCONV)\n"
"{\n"
"      \n"
"    const real TEMP = T[get_global_id(0)]*TCONV;\n"
"    const real PRES = P[get_global_id(0)]*PCONV;\n"
"\n"
"#ifdef DOUBLE_PRECISION\n"
"    const real SMALL = CPREC(1.0e-50);\n"
"#else\n"
"    const real SMALL = FLT_MIN;\n"
"#endif\n"
"\n"
"    real SUM, ctmp;\n"
"\n"
"    SUM = 0.0;\n"
"\n"
"    C(1)  = ctmp = Y(1) *CPREC(4.96046521e-1);\n"
"    SUM  += ctmp;\n"
"    C(2)  = ctmp = Y(2) *CPREC(9.92093043e-1);\n"
"    SUM  += ctmp;\n"
"    C(3)  = ctmp = Y(3) *CPREC(6.25023433e-2);\n"
"    SUM  += ctmp;\n"
"    C(4)  = ctmp = Y(4) *CPREC(3.12511716e-2);\n"
"    SUM  += ctmp;\n"
"    C(5)  = ctmp = Y(5) *CPREC(5.87980383e-2);\n"
"    SUM  += ctmp;\n"
"    C(6)  = ctmp = Y(6) *CPREC(5.55082499e-2);\n"
"    SUM  += ctmp;\n"
"    C(7)  = ctmp = Y(7) *CPREC(3.02968146e-2);\n"
"    SUM  += ctmp;\n"
"    C(8)  = ctmp = Y(8) *CPREC(2.93990192e-2);\n"
"    SUM  += ctmp;\n"
"    C(9)  = ctmp = Y(9) *CPREC(6.65112065e-2);\n"
"    SUM  += ctmp;\n"
"    C(10) = ctmp = Y(10)*CPREC(6.23323639e-2);\n"
"    SUM  += ctmp;\n"
"    C(11) = ctmp = Y(11)*CPREC(3.57008335e-2);\n"
"    SUM  += ctmp;\n"
"    C(12) = ctmp = Y(12)*CPREC(2.27221341e-2);\n"
"    SUM  += ctmp;\n"
"    C(13) = ctmp = Y(13)*CPREC(3.33039255e-2);\n"
"    SUM  += ctmp;\n"
"    C(14) = ctmp = Y(14)*CPREC(3.84050525e-2);\n"
"    SUM  += ctmp;\n"
"    C(15) = ctmp = Y(15)*CPREC(3.56453112e-2);\n"
"    SUM  += ctmp;\n"
"    C(16) = ctmp = Y(16)*CPREC(3.32556033e-2);\n"
"    SUM  += ctmp;\n"
"    C(17) = ctmp = Y(17)*CPREC(2.4372606e-2);\n"
"    SUM  += ctmp;\n"
"    C(18) = ctmp = Y(18)*CPREC(2.37882046e-2);\n"
"    SUM  += ctmp;\n"
"    C(19) = ctmp = Y(19)*CPREC(2.26996304e-2);\n"
"    SUM  += ctmp;\n"
"    C(20) = ctmp = Y(20)*CPREC(2.43467162e-2);\n"
"    SUM  += ctmp;\n"
"    C(21) = ctmp = Y(21)*CPREC(2.37635408e-2);\n"
"    SUM  += ctmp;\n"
"    C(22) = ctmp = Y(22)*CPREC(3.56972032e-2);\n"
"    SUM  += ctmp;\n"
"\n"
"    SUM = DIV (PRES, (SUM * (TEMP) * CPREC(8.314510e7)));\n"
"\n"
"// #pragma unroll 22\n"
"    for (unsigned k=1; k<=22; k++)\n"
"    {\n"
"        C(k) = MAX(C(k), SMALL) * SUM;\n"
"    }\n"
"}\n"
;

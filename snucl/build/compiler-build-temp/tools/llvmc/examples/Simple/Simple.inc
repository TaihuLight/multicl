//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// llvmc-based driver: auto-generated code
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Error.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

namespace llvmc {
namespace autogenerated {

cl::list<std::string> SinkOption(cl::Sink);

} // End namespace autogenerated.
} // End namespace llvmc.

namespace hooks {
} // End namespace hooks.

namespace {

using namespace llvmc::autogenerated;

class gcc : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "gcc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("gcc is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "gcc";


        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* gcc::InputLanguages_[] = {"c", 0};
const char* gcc::OutputLanguages_[] = {"executable", 0};

} // End anonymous namespace.

namespace llvmc {
namespace autogenerated {

int PreprocessOptions () {

    return 0;
}

int PopulateLanguageMap (LanguageMap& langMap) {
    langMap["c"] = "c";

    return 0;
}

int PopulateCompilationGraph (CompilationGraph& G) {
    G.insertNode(new gcc());

    if (int ret = G.insertEdge("root", new SimpleEdge("gcc")))
        return ret;

    return 0;
}

} // End namespace autogenerated.
} // End namespace llvmc.


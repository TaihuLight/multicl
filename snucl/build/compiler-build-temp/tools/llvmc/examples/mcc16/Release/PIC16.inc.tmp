//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// llvmc-based driver: auto-generated code
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Error.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

namespace llvmc {
namespace autogenerated {

cl::opt<bool> Switch_O1("O1"
, cl::ZeroOrMore, cl::desc("Optimization Level 1."));

cl::opt<bool> Switch_O2("O2"
, cl::ZeroOrMore, cl::desc("Optimization Level 2."));

cl::opt<bool> Switch_O3("O3"
, cl::ZeroOrMore, cl::desc("Optimization Level 3."));

cl::opt<bool> Switch_c("c"
, cl::ZeroOrMore, cl::desc("Stop after assemble, do not link"));

cl::list<std::string> List_D("D"
, cl::Prefix, cl::desc("Define a macro"));

cl::opt<bool> Switch_E("E"
, cl::ZeroOrMore, cl::desc("Stop after preprocessing, do not compile"));

cl::opt<bool> Switch_bc("bc"
, cl::ZeroOrMore, cl::desc("Stop after b-code generation, do not compile"));

cl::opt<bool> Switch_g("g"
, cl::ZeroOrMore, cl::desc("Enable Debugging"));

cl::list<std::string> List_I("I"
, cl::Prefix, cl::desc("Add a directory to include path"));

cl::opt<std::string> Parameter_regalloc("regalloc"
, cl::desc("Register allocator to use (possible values: simple, linearscan, pbqp, local; default=linearscan)"));

cl::list<std::string> List_K("K"
, cl::Prefix, cl::desc("Add a directory to linker script search path"));

cl::list<std::string> List_L("L"
, cl::Prefix, cl::desc("Add a directory to library path"));

cl::opt<std::string> Parameter_m("m"
, cl::desc("Generate linker map file with the given name"));

cl::opt<std::string> Parameter_k("k"
, cl::desc("Specify a linker script"));

cl::opt<std::string> Parameter_l("l"
, cl::desc("Specify a library to link"));

cl::opt<std::string> Parameter_p("p"
, cl::Prefix, cl::desc("Specify part name"));

cl::list<std::string> List_Wl_comma_("Wl,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to linker (Run 'mplink -help' for linker options)"));

cl::opt<bool> Switch_S("S"
, cl::ZeroOrMore, cl::desc("Stop after compilation, do not assemble"));

cl::opt<bool> Switch_Od("Od"
, cl::ZeroOrMore, cl::desc("Perform Debug-safe Optimizations only."));

cl::opt<bool> Switch_w("w"
, cl::ZeroOrMore, cl::desc("Disable all warnings."));

cl::opt<bool> Switch_X("X"
, cl::ZeroOrMore, cl::desc("Do not invoke mp2hex to create an output hex file."));

cl::list<std::string> List_Wa_comma_("Wa,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to assembler (Run 'gpasm -help' for assembler options)"));

cl::opt<bool> Switch_O0("O0"
, cl::ZeroOrMore, cl::desc("Do not optimize"));


} // End namespace autogenerated.
} // End namespace llvmc.

namespace hooks {
    std::string GetStdLinkerScriptsDir();
    std::string GetStdLibsDir();
    std::string GetStdHeadersDir();
    std::string GetLowerCasePartDefine();
    std::string GetBinDir();
    std::string GetUpperCasePartDefine();
    std::string GetStdAsmHeadersDir();
} // End namespace hooks.

namespace {

using namespace llvmc::autogenerated;

class clang_cc : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "clang_cc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("clang_cc is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = hooks::GetBinDir() + std::string("clang");
        vec.push_back(std::make_pair(0, "-cc1"));
        vec.push_back(std::make_pair(0, "-I"));
        vec.push_back(std::make_pair(0, hooks::GetStdHeadersDir()));
        vec.push_back(std::make_pair(0, "-D"));
        vec.push_back(std::make_pair(0, hooks::GetLowerCasePartDefine()));
        vec.push_back(std::make_pair(0, "-D"));
        vec.push_back(std::make_pair(0, hooks::GetUpperCasePartDefine()));
        vec.push_back(std::make_pair(0, "-triple=pic16-"));
        vec.push_back(std::make_pair(0, "-emit-llvm-bc"));

        if ((InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_bc) {
            stop_compilation = true;
            output_suffix = "bc";
        }
        if (autogenerated::Switch_g) {
            vec.push_back(std::make_pair(65536, "-g"));
        }
        if (autogenerated::Switch_w) {
            vec.push_back(std::make_pair(65536, "-w"));
        }
        if (autogenerated::Switch_O1) {
        }
        if (autogenerated::Switch_O2) {
        }
        if (autogenerated::Switch_O3) {
        }
        if (autogenerated::Switch_Od) {
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(65536, "-O0"));
        }
        else {
            vec.push_back(std::make_pair(65536, "-O1"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* clang_cc::InputLanguages_[] = {"c", 0};
const char* clang_cc::OutputLanguages_[] = {"llvm-bitcode", 0};

class gpasm : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "gpasm";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("gpasm is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("o");

        cmd = hooks::GetBinDir() + std::string("gpasm");
        vec.push_back(std::make_pair(0, "-z"));
        vec.push_back(std::make_pair(0, "-r"));
        vec.push_back(std::make_pair(0, "decimal"));
        vec.push_back(std::make_pair(0, "-I"));
        vec.push_back(std::make_pair(0, hooks::GetStdAsmHeadersDir()));
        vec.push_back(std::make_pair(0, "-C"));
        vec.push_back(std::make_pair(0, "-c"));
        vec.push_back(std::make_pair(0, "-w"));
        vec.push_back(std::make_pair(0, "2"));

        if (autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_g) {
            vec.push_back(std::make_pair(65536, "-g"));
        }
        if (!autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_p.getPosition(), "-p" + autogenerated::Parameter_p));
        }
        if (autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(65536, "-p"));
            vec.push_back(std::make_pair(65536, "16f1xxx"));
        }
        if (!autogenerated::List_Wa_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wa_comma_.begin(), 
                 E = autogenerated::List_Wa_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wa_comma_.getPosition(B - autogenerated::List_Wa_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* gpasm::InputLanguages_[] = {"assembler", 0};
const char* gpasm::OutputLanguages_[] = {"object-code", 0};

class llc : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "llc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llc is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("s");

        cmd = hooks::GetBinDir() + std::string("llc");
        vec.push_back(std::make_pair(0, "-march=pic16"));
        vec.push_back(std::make_pair(0, "-disable-jump-tables"));
        vec.push_back(std::make_pair(0, "-pre-RA-sched=list-burr"));
        vec.push_back(std::make_pair(0, "-f"));

        if (autogenerated::Switch_S) {
            stop_compilation = true;
        }
        if (!autogenerated::Parameter_regalloc.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_regalloc.getPosition(), "-regalloc"));
            vec.push_back(std::make_pair(autogenerated::Parameter_regalloc.getPosition(), autogenerated::Parameter_regalloc));
        }
        if (autogenerated::Parameter_regalloc.empty()) {
            vec.push_back(std::make_pair(65536, "-regalloc=linearscan"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llc::InputLanguages_[] = {"llvm-bitcode", 0};
const char* llc::OutputLanguages_[] = {"assembler", 0};

class llvm_ld : public JoinTool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "llvm_ld";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = hooks::GetBinDir() + std::string("llvm-ld");
        vec.push_back(std::make_pair(0, "-L"));
        vec.push_back(std::make_pair(0, hooks::GetStdLibsDir()));
        vec.push_back(std::make_pair(0, "-disable-licm-promotion"));
        vec.push_back(std::make_pair(0, "-l"));
        vec.push_back(std::make_pair(0, "std"));

        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O2) {
        }
        if (autogenerated::Switch_O3) {
        }
        else {
            vec.push_back(std::make_pair(65536, "-disable-inlining"));
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-b"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = hooks::GetBinDir() + std::string("llvm-ld");
        vec.push_back(std::make_pair(0, "-L"));
        vec.push_back(std::make_pair(0, hooks::GetStdLibsDir()));
        vec.push_back(std::make_pair(0, "-disable-licm-promotion"));
        vec.push_back(std::make_pair(0, "-l"));
        vec.push_back(std::make_pair(0, "std"));

        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O2) {
        }
        if (autogenerated::Switch_O3) {
        }
        else {
            vec.push_back(std::make_pair(65536, "-disable-inlining"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-b"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_ld::InputLanguages_[] = {"llvm-bitcode", 0};
const char* llvm_ld::OutputLanguages_[] = {"llvm-bitcode", 0};

class llvm_ld_optimizer : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "llvm_ld_optimizer";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_ld_optimizer is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = hooks::GetBinDir() + std::string("llvm-ld");

        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (autogenerated::Switch_O2) {
        }
        if (autogenerated::Switch_O3) {
        }
        else {
            vec.push_back(std::make_pair(65536, "-disable-inlining"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-b"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_ld_optimizer::InputLanguages_[] = {"llvm-bitcode", 0};
const char* llvm_ld_optimizer::OutputLanguages_[] = {"llvm-bitcode", 0};

class mplink : public JoinTool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "mplink";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("cof");

        cmd = hooks::GetBinDir() + std::string("mplink");
        vec.push_back(std::make_pair(0, "-e"));
        vec.push_back(std::make_pair(0, "-k"));
        vec.push_back(std::make_pair(0, hooks::GetStdLinkerScriptsDir()));
        vec.push_back(std::make_pair(0, "-l"));
        vec.push_back(std::make_pair(0, hooks::GetStdLibsDir()));
        vec.push_back(std::make_pair(0, "intrinsics.lib"));
        vec.push_back(std::make_pair(0, "stdn.lib"));

        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(), 
                 E = autogenerated::List_Wl_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }
        if (autogenerated::Switch_X) {
            vec.push_back(std::make_pair(65536, "-x"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_K.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_K.begin(),
            E = autogenerated::List_K.end(); B != E;) {
                unsigned pos = autogenerated::List_K.getPosition(B - autogenerated::List_K.begin());
                vec.push_back(std::make_pair(pos, "-k" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_m.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_m.getPosition(), "-m"));
            vec.push_back(std::make_pair(autogenerated::Parameter_m.getPosition(), autogenerated::Parameter_m));
        }
        if (!autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_p.getPosition(), "-p" + autogenerated::Parameter_p));
            vec.push_back(std::make_pair(65536, "-c"));
        }
        if (autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(65536, "-p"));
            vec.push_back(std::make_pair(65536, "16f1xxx"));
            vec.push_back(std::make_pair(65536, "-c"));
        }
        if (!autogenerated::Parameter_k.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_k.getPosition(), "-k"));
            vec.push_back(std::make_pair(autogenerated::Parameter_k.getPosition(), autogenerated::Parameter_k));
        }
        if (!autogenerated::Parameter_l.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_l.getPosition(), "-l"));
            vec.push_back(std::make_pair(autogenerated::Parameter_l.getPosition(), autogenerated::Parameter_l));
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("cof");

        cmd = hooks::GetBinDir() + std::string("mplink");
        vec.push_back(std::make_pair(0, "-e"));
        vec.push_back(std::make_pair(0, "-k"));
        vec.push_back(std::make_pair(0, hooks::GetStdLinkerScriptsDir()));
        vec.push_back(std::make_pair(0, "-l"));
        vec.push_back(std::make_pair(0, hooks::GetStdLibsDir()));
        vec.push_back(std::make_pair(0, "intrinsics.lib"));
        vec.push_back(std::make_pair(0, "stdn.lib"));

        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(), 
                 E = autogenerated::List_Wl_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }
        if (autogenerated::Switch_X) {
            vec.push_back(std::make_pair(65536, "-x"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_K.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_K.begin(),
            E = autogenerated::List_K.end(); B != E;) {
                unsigned pos = autogenerated::List_K.getPosition(B - autogenerated::List_K.begin());
                vec.push_back(std::make_pair(pos, "-k" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_m.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_m.getPosition(), "-m"));
            vec.push_back(std::make_pair(autogenerated::Parameter_m.getPosition(), autogenerated::Parameter_m));
        }
        if (!autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_p.getPosition(), "-p" + autogenerated::Parameter_p));
            vec.push_back(std::make_pair(65536, "-c"));
        }
        if (autogenerated::Parameter_p.empty()) {
            vec.push_back(std::make_pair(65536, "-p"));
            vec.push_back(std::make_pair(65536, "16f1xxx"));
            vec.push_back(std::make_pair(65536, "-c"));
        }
        if (!autogenerated::Parameter_k.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_k.getPosition(), "-k"));
            vec.push_back(std::make_pair(autogenerated::Parameter_k.getPosition(), autogenerated::Parameter_k));
        }
        if (!autogenerated::Parameter_l.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_l.getPosition(), "-l"));
            vec.push_back(std::make_pair(autogenerated::Parameter_l.getPosition(), autogenerated::Parameter_l));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* mplink::InputLanguages_[] = {"object-code", 0};
const char* mplink::OutputLanguages_[] = {"executable", 0};

class pic16passes : public Tool {
private:
    static const char* InputLanguages_[];
    static const char* OutputLanguages_[];

public:
    const char* Name() const {
        return "pic16passes";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char** OutputLanguages() const {
        return OutputLanguages_;
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("pic16passes is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("obc");

        cmd = hooks::GetBinDir() + std::string("opt");
        vec.push_back(std::make_pair(0, "-pic16cloner"));
        vec.push_back(std::make_pair(0, "-pic16overlay"));
        vec.push_back(std::make_pair(0, "-f"));

        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* pic16passes::InputLanguages_[] = {"llvm-bitcode", 0};
const char* pic16passes::OutputLanguages_[] = {"llvm-bitcode", 0};

class Edge2: public Edge {
public:
    Edge2() : Edge("llvm_ld_optimizer") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_S) {
            ret += 2;
        }
        if (autogenerated::Switch_c) {
            ret += 2;
        }
        return ret;
    }

};

class Edge6: public Edge {
public:
    Edge6() : Edge("llvm_ld_optimizer") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_S) {
            ret += 2;
        }
        if (autogenerated::Switch_c) {
            ret += 2;
        }
        return ret;
    }

};

} // End anonymous namespace.

namespace llvmc {
namespace autogenerated {

int PreprocessOptions () {

    return 0;
}

int PopulateLanguageMap (LanguageMap& langMap) {
    langMap["c"] = "c";
    langMap["i"] = "c-cpp-output";
    langMap["s"] = "assembler";
    langMap["S"] = "assembler-with-cpp";
    langMap["ll"] = "llvm-assembler";
    langMap["bc"] = "llvm-bitcode";
    langMap["o"] = "object-code";
    langMap["cof"] = "executable";

    return 0;
}

int PopulateCompilationGraph (CompilationGraph& G) {
    G.insertNode(new clang_cc());
    G.insertNode(new gpasm());
    G.insertNode(new llc());
    G.insertNode(new llvm_ld());
    G.insertNode(new llvm_ld_optimizer());
    G.insertNode(new mplink());
    G.insertNode(new pic16passes());

    if (int ret = G.insertEdge("root", new SimpleEdge("clang_cc")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_ld")))
        return ret;
    if (int ret = G.insertEdge("root", new Edge2()))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("gpasm")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("mplink")))
        return ret;
    if (int ret = G.insertEdge("clang_cc", new SimpleEdge("llvm_ld")))
        return ret;
    if (int ret = G.insertEdge("clang_cc", new Edge6()))
        return ret;
    if (int ret = G.insertEdge("llvm_ld", new SimpleEdge("pic16passes")))
        return ret;
    if (int ret = G.insertEdge("llvm_ld_optimizer", new SimpleEdge("pic16passes")))
        return ret;
    if (int ret = G.insertEdge("pic16passes", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llc", new SimpleEdge("gpasm")))
        return ret;
    if (int ret = G.insertEdge("gpasm", new SimpleEdge("mplink")))
        return ret;

    return 0;
}

} // End namespace autogenerated.
} // End namespace llvmc.

